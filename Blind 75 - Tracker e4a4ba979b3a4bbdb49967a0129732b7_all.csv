Name,Problem,Difficulty,Tags,Notes
1,Two Sum,Easy,"Array, Hashmap","Use hash-map to check for difference value, map will add index of last occurrence of a num, don’t repeat element"
121,Best Time to Buy and Sell Stock,Easy,"Array, Two Pointers","Initialize maxProfit and two pointers. Use while, for each pair check it profitable and store the max. If not profit move left = right. Either case move right one."
169.,Majority Element,Easy,Array,"Boyer-Moore Voting algorithm. Consider element appears [N/2], majority element will balance on top at the end. Initialize candidate value and counter. If counter == 0, reset candidate to value, else check if (index) value equals candidate to add 1"
217,Contains Duplicate,Easy,"Array, Set","Create value set. If value not in set add, else return True (means there is already one)"
57,Insert Interval,Medium,Array,"Check if interval goes at the beginning, or if the newInterval is bigger than current one we keep adding to the result. Else we generate the merge and add to result."
15,3Sum,Medium,"Array, Set, Two Pointers","Sort (help with duplicates). For each element, skip duplicates, then 2 pointers, one after current element and one at end of array. Find sum. If more than zero, move R (-) less than zero move L (+), if zero add triplet to results. After valid triplet, skip over duplicates"
238,Product of array except self,Medium,"Array, Precompute","We are looking for all elements from 0 to i-1 and i+1 to n. Divide into 2 subproblems according to initial statement. For all elements less than i, lets make left[] and also for right[] in the end, combine the two arrays."
39," Combination Sum",Medium,"Array, BackTrack, DFS","Naive backtracking solution recursive approach. To choices for each element: consider it into current set, do not consider it. Base cases: if sum == target end recursive call and add to list (return). If sum is more than target or finish array, terminate call. Iterate from the index to finish. Add to comb - track - remove"
56,Merge Intervals,Medium,"Array, Merge","Sort intervals by start (facilitate insertion). Initialize result array with first interval[0]. Iterate over intervals. If start is less/equalto the end of last element in result, we merge (update the last end by choosing the max between lastend and current end) else just append result"
75,Sort Colors,Medium,"Array, Quicksort","Sorts an array of 0s, 1s, and 2s by keeping track of the rightmost boundaries of 0s and 1s using three pointers (zero, one, two), initially set to -1. As it iterates through the array, it moves these pointers to the right to expand the boundaries for each color, and overwrites the array elements with the correct color values based on the current number and pointer positions."
11,Container with most water,Medium,"Array, Two Pointers","Initialize two pointers, L at start and R at finish. Initialize a max_volume. By iteration get the min height and calculate area. If height on left is lower than height on right move left, if move right is less that height left move right (-). else just move left (+), keep updating max volume."
134,Gas Station,Medium,Array,"Pigeon hole principle. First determine if there is enough gas, or not (sum(gas) < sum(cost)). Initialize tank and index as 0. Traverse gas for each iteration add up to tank (gas[i[ - cost[i]). If tank is negative, reset tank and update index(+)"
226,Invert Binary Tree,Easy,"Binary Tree, DFS",Depth First search. We need to traverse tree and for every node swap the children.
110,Balanced Binary Tree,Easy,"Binary Tree, DFS","For every node we verify condition. In the recursion call we ask, are you balanced and what is your height? For every node we get the height of left and right and determine if balanced (abs(left-right)) ≤ 1. In case its bigger flag is updated. For every node we obtain the max (deepest node)"
543,Diameter of Binary Tree,Easy,"Binary Tree, DFS",For every node we check height of children. We keep track of maxPath (sum of height (left + right)) → we use list because of the nature of its mutability
104,Maximum Depth of Binary Tree,Easy,"Binary Tree, DFS","For each node, calculate max depth of left and right and get the max.  Return 1 + plus de maximum of the depths of left and right subtrees, as depth of current node."
102,Binary Tree Level Order Traversal,Medium,"BFS, Binary Tree","Implement BFS. Start a queue and an output list. While queue start a sublist for the length of queue add to list current. If left or right add to queue. add sublist to output, repeat."
236,Lowest Common Ancestor (not search tree),Medium,"Binary Tree, DFS","Base case: if root is none or if its equal to p or q. If met we have found one we are looking for. Next, we recursively call method on left and right subtrees of current storing results. If both are not None we have found in other subtrees, else we return the node whichever is not null."
199,Binary tree right side view,Medium,"BFS, Binary Tree","Using BFS, we. traverse the tree. We add BOTH nodes to the queue. However we validate if the node is the last on the current level. If so, add value to result."
105,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/,Medium,Binary Tree,Consider how preorder and inorder are built. Establish root as preorder[0] and mid as inorder.index(preorder[0]). then construct left and right nodes recursively. LEFT → preorder[1:mid+1] inorder[:mid] and RIGHT → preorder[mid+1:] inorder[mid+1:]
235,Lowest Common Ancestor of Binary Search Tree,Medium,"Binary Tree, Search Tree","Recursively. # if the value of p and q is less than the root, ancestor will be on the left subtree or # if the value of p and q is more than the root, ancestor will be on the right subtree, else return root (current)"
98,Validate Binary Search Tree,Medium,"Binary Tree, Search Tree","Initialize stack with three values (lowerBound, root (current), upperBound) check that current value.val is between bounds. If left update upper bound to current value, if right update lower bound to current.val"
230,https://leetcode.com/problems/kth-smallest-element-in-a-bst/,Medium,"Binary Tree, Search Tree","Considering its a binary search tree, let utilize the the property of inorder traversal. Its stores values in ascending order. When traversal is completed just return res[k-1] value."
704,Binary Search,Easy,Binary Search,Standard implementation of binary search O(log n)
278,https://leetcode.com/problems/first-bad-version/,Easy,Binary Search,Binary Search modification. Remember its 1-indexed and that validation is < instead of ≤
33,https://leetcode.com/problems/search-in-rotated-sorted-array/,Medium,Binary Search,Initialize same as binary search. However check portions. If nums[left] ≤ nums[mid] it implies left half is sorted in ascending order. Check if target is within bounds other wise move to right. Else if nums[left] > nums[mid] is in the other half. Check where is should go and repeat
981,https://leetcode.com/problems/time-based-key-value-store/,Medium,Binary Search,Implement binary search modification through hash-map implementation.
125,Valid Palindrome,Easy,"String, Two Pointers","In case we need to develop out own alphanumeric function check we can use ord() and check wether the value falls between ""A"" and ""Z"" // ""a"" and ""z"" // ""0"" and ""9"" according to the alphanumeric code."
36,https://leetcode.com/problems/valid-sudoku/,Medium,Matrix,"Create defaultdict sets for rows[i], columns[j] and boxes[(i//3, j//3)] and traverse the matrix"
54,Spiral Matrix,Medium,Matrix,"Establish boundaries, top, bottom, right and left and traverse accordingly"
46,Permutations,Medium,"BackTrack, Recursion","Base case = len(currentPermutation) == len(nums): For num in nums if num not in permutation, add back track, pop."
,,,,